---
title: "Getting started with simulating data in R: some helpful functions and how to use them"
author: "Ariel Muldoon"
date: "August 28, 2018"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Overview

There are many reasons we might want to simulate data in R, and I find being able to simulate data to be incredible useful in my day-to-day work.  But how does someone get started simulating data?  Today I'm going to talk some of the functions R has available that are useful to get to know when simulating data.  While some of them may already be familiar to you, I thought we'd take a closer look at how to use them.

Here's the goal for today:

1. Simulate quantitative variables via random number generation with `rnorm()`, `runif()` and `rpois()` (rbinom?)
2. Generate character variables that represent groups via `rep()`.  We'll explore how to create variables with different patterns.
3. Dive into `replicate()` for repeating data simulation many times
4. (Possibly) Talk about looping through the simulations and pulling out results via `purrr::map()` loops and/or `for()` loops.

# Generating random numbers

An easy way to generate numeric data in a simulation situation is to pull random numbers from some distribution.  This can be done via the functions for pulling random deviates.  These functions always start with `r` (for "random").

The basic distributions that I use the most for generating random numbers are the normal (`rnorm()`), uniform (`runif()`), and Poisson (`rpois()`) distributions.  There are many others available as part of the **stats** package (e.g., binomial, log normal, beta, exponential, Gamma) and, as you can imagine, even more available in add-on packages.  I recently needed to generate data from the Tweedie distribution to test a modeling tool, which I could do via package **tweedie**.  

The `r` distribution functions all work basically the same way.  We define how many random numbers we want to generate in the first argument (`n`) and then define the parameters for the distribution we want to draw from.  This is easier to see with practice, so let's get started.

## `rnorm()` to generate random numbers from the normal distribution

I use `rnorm()` a lot, sometimes with good reason and other times when I need some numbers and I really don't care too much about what they are.

There are three arguments to `rnorm()`.  From the `Usage` section of the documentation:

> rnorm(n, mean = 0, sd = 1)

The `n` argument is the number of observations we want.  The `mean` and `sd` arguments show what the default values are (note that `sd` is the *standard deviation*, not the variance).

To get 5 random numbers from a $Normal(0, 1)$ (aka the *standard* normal) distribution I can write code like:

```{r}
rnorm(5)
```

There's a couple things about this code and output to discuss.  

First, if you were to run this code you would get different numbers.  To get reproducible random numbers we need to *set the seed*.

### Setting the random seed for reproducible random numbers

If you need to reproduce the random numbers you got so you can generate the exact same numbers you'll need to set the seed via `set.seed()`.

Setting the seed means the random numbers generated are reproducible.  I use this in teaching/blogging so that anyone following along with my code will be able to exactly reproduce my results.  I also will set the seed when I'm working on a repeated simulation and I want to make sure that a function I wrote works correctly.  Otherwise in most simulations we don't actually want to set the seed.

If we set the seed, run the random number generation and then do it again we will get the same values.

```{r}
set.seed(16)
rnorm(5)
```

```{r}
set.seed(16)
rnorm(5)
```

Second, the code I used got me 5 numbers, which is what I wanted, but the code itself isn't particularly clear.  What I would call lazy coding on my part can look pretty mysterious to someone reading my code (or to my future self reading my code).  It's not clear exactly what the parameters of the distribution was set to since I used the default settings.  

Here's clearer code to do the same thing, where I write out the mean and standard deviation arguments even though I'm using the default values.  It is not necessary to always be this careful, but I figure it's better to start out understanding the code and then you can start taking shortcuts later.

```{r}
rnorm(n = 5, mean = 0, sd = 1)
```

### Change parameters in `rnorm()`

For getting a quick set of numbers it's easy to use the default parameter values in `rnorm()`.  But we can definitely change these.  When I'm exploring long-run behavior of variance estimated from linear models, though, I'll focus on different standard deviations.

The `sd` argument shows the *standard deviation* of the normal distribution.  So drawing from a $Normal(0, 4)$ would be achieved by setting `sd` to 2.

```{r}
rnorm(10, mean = 0, sd = 2)
```

I've seen others change the mean and standard deviation to get more specific ranges of variables.

If the mean is large and the standard deviation small in relation to the mean we can generate strictly positive numbers.  (I usually use `runif()` for this, which we'll see below).

```{r}
rnorm(6, mean = 50, sd = 20)
```

### Using vectors for the parameter arguments

We can pull random numbers from a normal distribution with distinct parameters if we use a vector for the parameter arguments.  For example, this could be useful for simulating data with different group means but the same variance (like we would use if fitting an ANOVA).

I'll keep the standard deviation at 1 but will draw data with a mean of 0, 5, and 20.  Note that repeating pattern: the function draws one value from each distribution until the total number requested is reached.

```{r}
rnorm(10, mean = c(0, 5, 20), sd = 1)
```

```{r}
rnorm(5, mean = c(0, 5, 20), sd = 1)
```

## Using simulated data

Up to this point we've printed the results of each simulation but we haven't done anything with it.  

In reality we'd want to save our vectors as objects in R to use them for some further analysis.  For example, maybe we want to simulate two unrelated variables.  This can be a fun exercise to drive home how by chance we can see variables that appear to be related even though we know they are not.

I'll generate two quantitative vectors of length 10, which I'll name `x` and `y`, and plot the results.

```{r}
x = rnorm(10, 0, 1)
y = rnorm(10, 0, 1)
plot(y ~ x)
```

Depending on the simulation goal, storing the vectors in a data.frame can help keeps things organized.

```{r}
dat = data.frame(x = rnorm(10, 0, 1),
                 y = rnorm(10, 0, 1) )
plot(y ~ x, data = dat)
```


## `runif()` pulls from the uniform distribution

Pulling random numbers from other distributions is extremely similar to using `rnorm()`, and we'll go through them more quickly.

I've started using `runif()` more regularly, especially when I want to generate numbers that are strictly positive but continuous.  The uniform distribution are continuous numbers uniformly distributed between some minimum and maximum.

From `Usage` we can see that by default we pull random numbers between 0 and 1.  The first argument, as with all of these `r` functions, is the number of numbers we want to randomly generate:

> runif(n, min = 0, max = 1)

Let's generate 5 numbers between 0 and 1.

```{r}
runif(5, 0, 1)
```

What if we want to generate 5 numbers between 50 and 100?  We can change the parameter values.

```{r}
runif(5, 50, 100)
```

I've used this when I wanted to show the effect of having very different ranges of variables on the size of the estimated coefficient in a regression.

Let's generate some data with the response variable (`y`) pulled from a standard normal distribution and the explanatory variable with values between 1 and 2.

We'll use the data in a regression model fit via `lm()`.  Let's set the seed so we can reproduce `y` when we change the range of the explanatory variable.

```{r}
set.seed(16)
dat = data.frame(x = runif(10, 1, 2),
                 y = rnorm(10, 0, 1) )
lm(y ~ x, data = dat)
```

Now simulate a new dataset with the same `y` but an explanatory variable between 100 and 200.  You'll see new slope coefficient is exactly 1/100th of the coefficient above.

```{r}
set.seed(16)

dat = data.frame(x = runif(10, 100, 200),
                 y = rnorm(10, 0, 1) )
lm(y ~ x, data = dat)
```

## Discrete counts with `rpois()`

Let's look at one last function for generating random numbers, this time for generating discrete integers (including 0) from a Poisson distribution with `rpois()`.

I use `rpois()` for generating counts for generalized linear models.  This can also be used to get an idea of the shape of the Poisson distribution with different means, which can be enlightening when thinking about a distribution to analyze count data with.

The Poisson distribution is a single parameter distribution.  The function looks like:

> rpois(n, lambda)

Note there is only a single parameter, which is the mean, and it has no default setting.

Let's generate a few values from a Poisson distribution with a mean of 2.5.  Note that mean can be any non-negative value (i.e., it doesn't have to be an integer).

```{r}
rpois(5, lambda = 2.5)
```

Let's explore the Poisson distribution a little more.  Let's draw 100 values from a Poisson distribution with a mean of 5.  We'll name this vector `y` and take a look at a summary of those values.


```{r}
y = rpois(100, lambda = 5)
```

The vector of values we simulated fall between 1 and 12.

```{r}
summary(y)
```

We can see there is mild right-skew when we draw a histogram of the values.

```{r}
hist(y)
```

Let's do the same thing for a Poisson distribution with a mean of 100.  The range of values is pretty narrow.

```{r}
y = rpois(100, lambda = 100)
summary(y)
```

And the distribution looks pretty symmetric compared to the smaller mean.

```{r}
hist(y)
```


# Generate character vectors with `rep()`

Quantitative variables are great, but in simulations we're going to need categorical variables, as well.  Most often in my work these are some sort of "grouping" or "treatment" variable.

## Using `letters` and `LETTERS`

One thing you might see when looking at someone's simulation code is the use of `letters` or `LETTERS` for creating categorical variables.  These are *built in constants* in R.  `letters` is for the 26 lowercase letters of the Roman alphabet and `LETTERS` for the same in uppercase.

Letters can be pulled out via the extract brackets (`[`).  I use these for pure convenience when I need some quick categorical vectors.  SI find it easier to type out the work and brackets than a vector of characters.

```{r}
letters[1:2]
```

```{r}
LETTERS[10:26]
```

## Repeat each element of a vector with `each`

Since character variables often represent some sort of grouping, we need to have multiple observations of each character in some pattern.  The `rep()` function is one way to avoid having to manually write out the vector.

There are three arguments that help us repeat with different patterns: `each`, `times`, and `length.out` that can be used individually or in combination.

With `each` we repeat each unique character in the vector the number of times we define.  The characters are therefore clumped together.  

This is the sort of grouping variable I might make for simulating for a two-sample analysis.

```{r}
rep(letters[1:2], each = 3)
```

## Repeat a whole vector with the `times` argument

Another way to repeat a vector is to repeat the whole vector rather than repeat it elementwise like we did with `each`. That's what the `times` argument is for.

We'll make a two-group variable again, but this time we'll change the pattern of the values in the variable.

```{r}
rep(letters[1:2], times = 3)
```

## Repeat each element a different number of `times`

We can use `times` with a vector instead of an integer value to repeat each element of the character vector a different number of times.  This is one way to simulate unbalanced groups.

Let's repeat the first element twice but the second three times.

```{r}
rep(letters[1:2], times = c(2, 3) )
```

## Using `length.out` argument

The `length.out` argument has `rep()` repeat the whole vector much like `times` does.  However, it repeats only until the defined length is reached.  Using `length.out` is another way to get unbalanced groups.  

Rather than defining the number of repeats like we did with `each` and `times` we define how long the final variable should be.  Here's I'll make a two-group variable of length 5, so one group will have one less value than the other.

```{r}
rep(letters[1:2], length.out = 5)
```

## Combining `each` with `times`

Depending on how complicated the situation is that you are simulating data for, you may need more complicated patterns in your categorical variable.  The `each` argument can be combined with `times` to first repeat each value elementwise (via `each`) and then repeat that pattern.

When we use `times` this way it must take a single value and not a vector.

```{r}
rep(letters[1:2], each = 2, times = 3)
```

## Combining `each` with `length.out`

Similarly we can use `each` with `length.out`.  This can impart imbalance.

```{r}
rep(letters[1:2], each = 2, length.out = 7)
```

Note you can't use `length.out` and `times` together (if you try, `length.out` will be given priority and `times` ignored).

# Creating combinations of quantiative and categorical data

We now have some tools for creating quantitative data as well as categorical.  Which means we can make an actual dataset!

Let's start by simulating data that we would use in a simple two-sample analsyis.

This is mostly using the tools we did but putting things in a data.frame to keep things organized.

One option is to make separate vectors of different lengths and then bind them together via `data.frame()`.  Notice there is no need to use `cbind()` here, which we often think we need as R beginners,.  Instead we can use `data.frame()` directly.

```{r}
group = rep(letters[1:2], each = 3)
response = rnorm(6, 0, 1)
data.frame(group,
           response)
```

If I'm going to make a data.frame like this I prefer to make my vectors and the data.frame simultaneously to avoid having a lot of variables cluttering up my R Environment.

```{r}
data.frame(group = rep(letters[1:2], each = 3),
           response = rnorm(6, 0, 1) )
```

Now let's add another categorical variable.  Let's say we have a situation with two factors.  Each observation has a value of `group` and a value of second factor we'll call `factor`.  That factor will take on the values "C", "D", and "E".

This means we need to repeat the variable with a different pattern than `group`.

```{r}
data.frame(group = rep(letters[1:2], each = 3),
           factor = rep(LETTERS[3:5], times = 2),
           response = rnorm(6, 0, 1) )
```


# Repeatedly simulating data with `replicate()`

The `replicate()` function is a real workhorse when making repeated simulations.
